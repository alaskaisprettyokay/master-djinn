{:enums
    {:ActionTypes
        {:description "General categories for actions"
        :values [
            :Exercise
            :Socialize
            :Internalize
            :Perceiving
            :Walking
            :Running
            :Dancing
            :Biking
            :Talking
            :Calling
            :Facetiming
            :Socializing
            :Partying
            :Messaging
            :Coding
            :Eating]}
    :ActionRelations
        {:description "Allowed Neo4j relations between players and actions"
        :values [:DID]}

    :ResourceTypes
        {:description "General categories for resources"
        :values [
            :Software
            :Music
        ]}
    :ResourceAccessibility
        {:description "How resources can be viewed and consumed by players"
        :values [
            :Public ;; anyone can see and use
            :Permissioned ;; publically viewable but requires access rights
            :Private ;; can only be seen and used with access rights
            :Secret ;; can only be seen and used with access rights
        ]}
    :ResourceRelations
        {:description "How avatars and actions interact with resources"
        :values [
            :MONITORS
            :CONTROLS
            :STEWARDS
            :CONSUMES
            :GENERATES
        ]}

    :Providers
        {:description "Valid Data Providers. 
                Unique game items that players can equip.
                Possible that a data provider can also be a data source. Or a data source could appear in multiple data providers."
        :values [
            :IphoneHealthKit
            :IwatchHealthKit
            :AndroidHealthConnect
            :Github
            :Spotify
        ]}
    }

    :input-objects 
        {:SignedRequest
            {:description "Cryprographic signature and data to verify that the GQL query sent was signed by player.
                variable values aren't included in query so shouldnt cause recursion issue with different hashes.
                signature = eth_signMessage(query)
                nonce = optional value provided to player by server they are querying to prevent replay attacks"
            :fields {
                :_raw_query {:type String }
                :signature {:type (non-null String) }
                ;; :nonce {:type String }
            }}
        :RawInputData
            {:description "Any unprocessed data collected from data providers. GraphQL doesnt have a general <any> or <object> type so this is a catch all."
            :fields {
                :id {:type String} ;; uuid in data provider system
                :count {:type Int}
                :timestamp {:type String} ;; exact time action occured
                ;; timespan that action occured over
                :startTime {:type String}
                :endTime {:type String}
                :startDate {:type String}
                :endDate {:type String}
                :metadata {:type :RawInputMetadata}
            }}
        :RawInputMetadata
            {:description "Info on how data was collected from data provider provider. GraphQL doesnt have a general <any> or <object> type so this is a catch all."
            :fields {
                :id {:type String} ;; uuid in data provider system
                :clientRecordId {:type String} ;; uuid in data provider system
                :clientRecordVersion {:type String} ;; exact time action occured
                :device {:type String} ;; exact time action occured
                ;; timespan that action occured over
                :lastModifiedTime {:type String}
                :dataOrigin {:type String}
                :recordingMethod {:type String}
            }}
    }
    :objects
        {:Avatar {:fields {
            :id {:type (non-null String)}
            :name {:type String}
            :birthday {:type String}
            :homies {:type (list :Avatar)}
        }}
        :Action {:fields {
            ;; make interface if we need abstract for incipient/consequential
            ;; :implements [:Action]
            
            :id {:type (non-null String)}
            :desc {:type String}
            :action_type {:type (non-null String)}
            :startTime {:type (non-null String)} ;; ISO string '2023-06-20T23:53:15.405Z'
            :endTime {:type (non-null String)} ;; ISO string '2023-06-20T23:53:15.405Z'
            :provider {:type (non-null :Providers)}
            :player {:type :Avatar} ;; Action may have multiple players? or no player if its projected?
        }}
        :Resource {:fields {
            ;; make interface if we need abstract for public/permissioned/private
            ;; :implements [:Resource]

            :uuid {:type (non-null String)}
            :provider_id {:type (non-null String)}
            :name {:type (non-null String)}
            :desc {:type String}
            :resource_type {:type String}
            :image {:type String}
            :url {:type String} ;; link to view data on resource
            :creators {:type (list Avatar)}
        }}
        :Query {:fields {
            :players {:type (list :Avatar)}
            :spotify_top_tracks
                {:type       (list Resource)
                :description "gets top tracks on spotify for a player"
                :args       {:target_player {:type (non-null String)}}}
            ;; :jinni {:type (non-null :Avatar)
            ;;     :args {:player_id {:type String}}}
            ;; ;; get all of a players jin not just their primary.
            ;; ;; Here to remind me that i want people to bond to multiple jinn so i dont fuck up architecture
            ;; :my-jinn {:type (list :Avatar)
            ;;     :args {:player_id {:type String}}}
            
            ;; :player-actions {:type (list :Action)}
            ;;     :args {:player_id {:type (non-null String)
            ;;             :type (:type String)}
        }}
        :Mutation {:fields  {
            :submit_data
                {:type        (list ID)
                :description "Submit new game action data from players and return :Action UUIDs created"
                :args       {:verification {:type :SignedRequest} ;; non-null for now
                            :raw_data {:type (list :RawInputData)}
                            :provider {:type (non-null :Providers)}
                            :action_type {:type (non-null String)} ;; Non-normalized action name from data provider. e.g. Step for android health
                            :player_id {:type (non-null String)}}}  ;; 0x ETH address
            
            :jinni_activate
                {:type       (non-null ID)
                :description "registers a new jinni using ZKP that you have received a majik card"
                :args       {:verification {:type :SignedRequest} ;; TODO ZKP?
                            :majik_msg {:type (non-null String)} ;; Signed player_id by majik card
                            :player_id {:type (non-null String)}}} ;; 0x ETH address they will sign messages from
                
            :sync_provider_id
                {:type       String
                :description "adds a players username on a OAuth platform to their :Identity in our DB after granting access"
                :args       {:verification {:type :SignedRequest}
                            :provider {:type (non-null String)}
                            :player_id {:type (non-null String)}}} ;; 0x ETH address
            :sync_repos
                {:type       (list :Resource)
                :description "adds github /gitlab/radicle repos as :Resources to player used for tracking commits as game :Actions"
                :args       {:verification {:type :SignedRequest}
                            :provider {:type (non-null String)}
                            :player_id {:type (non-null String)}}} ;; 0x ETH address
            :track_commits
                {:type       (list ID)
                :description "Gets all the commits by player since we last checked on the repos they've added to their :Identity
                            Returns UUID of :Actions for commits"
                :args       {:verification {:type :SignedRequest}
                            :provider {:type (non-null String)}
                            :player_id {:type (non-null String)}}} ;; 0x ETH address

            :spotify_follow
                {:type       String
                :description "follows other players from current players spotify account"
                :args       {:verification {:type (non-null :SignedRequest)}
                            :target_players {:type (list (non-null String))}}}
            :spotify_disco
                {:type       String
                :description "creates a local silent disco"
                :args       {:playlist_id {:type (non-null String)}}}
            }}
    }
}
